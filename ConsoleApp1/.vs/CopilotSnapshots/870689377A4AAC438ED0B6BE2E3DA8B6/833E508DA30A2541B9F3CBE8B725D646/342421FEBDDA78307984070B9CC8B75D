using System;
using System.Collections.Generic;
using System.Linq;

namespace Nsga2CarDesign
{
    // ============ Problem definition ============
    public class DesignVariable
    {
        public string Name { get; }
        public double Min { get; }
        public double Max { get; }

        public DesignVariable(string name, double min, double max)
        {
            Name = name; Min = min; Max = max;
        }

        public double Clamp(double v) => Math.Max(Min, Math.Min(Max, v));
    }

    public interface IMultiObjectiveProblem
    {
        IReadOnlyList<DesignVariable> Vars { get; }
        // Return objectives to MINIMIZE: f1, f2
        (double f1, double f2) Evaluate(double[] x);
    }

    // ============ Individual ============
    public class Individual
    {
        public double[] X;              // decision variables
        public double F1, F2;           // objectives (minimize)
        public int Rank;                // non-dominated rank (1 is best)
        public double Crowding;         // crowding distance

        public List<Individual> Dominates = new List<Individual>();
        public int DominatedCount = 0;

        public Individual(int nVars)
        {
            X = new double[nVars];
        }

        public Individual Clone()
        {
            return new Individual(X.Length)
            {
                X = (double[])X.Clone(),
                F1 = F1,
                F2 = F2,
                Rank = Rank,
                Crowding = Crowding
            };
        }
    }

    // ============ NSGA-II ============
    public class Nsga2
    {
        private readonly IMultiObjectiveProblem _problem;
        private readonly Random _rng;

        public int PopulationSize { get; }
        public int Generations { get; }
        public double CrossoverProb { get; }
        public double MutationProbPerVar { get; }

        public Nsga2(IMultiObjectiveProblem problem, int popSize, int generations,
                     double crossoverProb = 0.9, double mutationProbPerVar = 0.1, int? seed = null)
        {
            _problem = problem;
            _rng = seed.HasValue ? new Random(seed.Value) : new Random();
            PopulationSize = popSize;
            Generations = generations;
            CrossoverProb = crossoverProb;
            MutationProbPerVar = mutationProbPerVar;
        }

        public List<Individual> Run()
        {
            var pop = InitPopulation();
            Evaluate(pop);
            AssignRankAndCrowding(pop);

            for (int gen = 0; gen < Generations; gen++)
            {
                var offspring = MakeOffspring(pop);
                Evaluate(offspring);

                // Combine parent + offspring
                var combined = pop.Concat(offspring).ToList();
                AssignRankAndCrowding(combined);

                // Environmental selection
                pop = SelectNextPopulation(combined, PopulationSize);

                // optional: print progress
                if ((gen + 1) % Math.Max(1, Generations / 10) == 0)
                {
                    var bestFront = pop.Where(i => i.Rank == 1).ToList();
                    Console.WriteLine($"Gen {gen + 1}/{Generations} | Front1 size: {bestFront.Count}");
                }
            }

            // Return final Pareto front (rank 1)
            return pop.Where(i => i.Rank == 1).OrderBy(i => i.F1).ToList();
        }

        private List<Individual> InitPopulation()
        {
            int n = _problem.Vars.Count;
            var pop = new List<Individual>(PopulationSize);
            for (int i = 0; i < PopulationSize; i++)
            {
                var ind = new Individual(n);
                for (int j = 0; j < n; j++)
                {
                    var v = _problem.Vars[j];
                    ind.X[j] = v.Min + _rng.NextDouble() * (v.Max - v.Min);
                }
                pop.Add(ind);
            }
            return pop;
        }

        private void Evaluate(List<Individual> pop)
        {
            foreach (var ind in pop)
            {
                (ind.F1, ind.F2) = _problem.Evaluate(ind.X);
            }
        }

        // ---------- Core NSGA-II: fast non-dominated sort ----------
        private void AssignRankAndCrowding(List<Individual> pop)
        {
            // reset domination info
            foreach (var p in pop)
            {
                p.Dominates.Clear();
                p.DominatedCount = 0;
                p.Rank = 0;
                p.Crowding = 0;
            }

            var fronts = FastNonDominatedSort(pop);
            for (int i = 0; i < fronts.Count; i++)
            {
                int rank = i + 1;
                foreach (var ind in fronts[i]) ind.Rank = rank;
                ComputeCrowdingDistance(fronts[i]);
            }
        }

        private List<List<Individual>> FastNonDominatedSort(List<Individual> pop)
        {
            var fronts = new List<List<Individual>>();
            var firstFront = new List<Individual>();

            for (int i = 0; i < pop.Count; i++)
            {
                var p = pop[i];
                for (int j = 0; j < pop.Count; j++)
                {
                    if (i == j) continue;
                    var q = pop[j];

                    if (Dominates(p, q))
                        p.Dominates.Add(q);
                    else if (Dominates(q, p))
                        p.DominatedCount++;
                }

                if (p.DominatedCount == 0)
                    firstFront.Add(p);
            }

            fronts.Add(firstFront);

            int k = 0;
            while (k < fronts.Count && fronts[k].Count > 0)
            {
                var next = new List<Individual>();
                foreach (var p in fronts[k])
                {
                    foreach (var q in p.Dominates)
                    {
                        q.DominatedCount--;
                        if (q.DominatedCount == 0)
                            next.Add(q);
                    }
                }
                if (next.Count > 0) fronts.Add(next);
                k++;
            }

            return fronts;
        }

        // Minimization: p dominates q if p is <= in both and < in at least one
        private static bool Dominates(Individual p, Individual q)
        {
            bool notWorse = (p.F1 <= q.F1) && (p.F2 <= q.F2);
            bool strictlyBetter = (p.F1 < q.F1) || (p.F2 < q.F2);
            return notWorse && strictlyBetter;
        }

        // ---------- Crowding distance ----------
        private static void ComputeCrowdingDistance(List<Individual> front)
        {
            if (front.Count == 0) return;

            foreach (var ind in front) ind.Crowding = 0;

            // objective 1
            front.Sort((a, b) => a.F1.CompareTo(b.F1));
            front[0].Crowding = double.PositiveInfinity;
            front[front.Count - 1].Crowding = double.PositiveInfinity;
            double minF1 = front[0].F1, maxF1 = front[front.Count - 1].F1;

            for (int i = 1; i < front.Count - 1; i++)
            {
                double denom = (maxF1 - minF1);
                if (denom > 1e-12)
                    front[i].Crowding += (front[i + 1].F1 - front[i - 1].F1) / denom;
            }

            // objective 2
            front.Sort((a, b) => a.F2.CompareTo(b.F2));
            front[0].Crowding = double.PositiveInfinity;
            front[front.Count - 1].Crowding = double.PositiveInfinity;
            double minF2 = front[0].F2, maxF2 = front[front.Count - 1].F2;

            for (int i = 1; i < front.Count - 1; i++)
            {
                double denom = (maxF2 - minF2);
                if (denom > 1e-12)
                    front[i].Crowding += (front[i + 1].F2 - front[i - 1].F2) / denom;
            }
        }

        // ---------- Reproduction ----------
        private List<Individual> MakeOffspring(List<Individual> pop)
        {
            var kids = new List<Individual>(PopulationSize);
            while (kids.Count < PopulationSize)
            {
                var p1 = TournamentSelect(pop);
                var p2 = TournamentSelect(pop);

                var c1 = p1.Clone();
                var c2 = p2.Clone();

                if (_rng.NextDouble() < CrossoverProb)
                    SimulatedBinaryCrossover(c1.X, c2.X);

                PolynomialMutation(c1.X);
                PolynomialMutation(c2.X);

                kids.Add(c1);
                if (kids.Count < PopulationSize) kids.Add(c2);
            }
            return kids;
        }

        private Individual TournamentSelect(List<Individual> pop)
        {
            var a = pop[_rng.Next(pop.Count)];
            var b = pop[_rng.Next(pop.Count)];

            // lower rank is better; if tie, higher crowding is better
            if (a.Rank < b.Rank) return a;
            if (b.Rank < a.Rank) return b;
            return (a.Crowding > b.Crowding) ? a : b;
        }

        // SBX crossover (simplified)
        private void SimulatedBinaryCrossover(double[] x1, double[] x2, double eta = 15.0)
        {
            for (int i = 0; i < x1.Length; i++)
            {
                if (_rng.NextDouble() > 0.5) continue;

                double u = _rng.NextDouble();
                double beta = (u <= 0.5)
                    ? Math.Pow(2 * u, 1.0 / (eta + 1))
                    : Math.Pow(1 / (2 * (1 - u)), 1.0 / (eta + 1));

                double c1 = 0.5 * ((1 + beta) * x1[i] + (1 - beta) * x2[i]);
                double c2 = 0.5 * ((1 - beta) * x1[i] + (1 + beta) * x2[i]);

                // clamp to bounds
                var v = _problem.Vars[i];
                x1[i] = v.Clamp(c1);
                x2[i] = v.Clamp(c2);
            }
        }

        // Polynomial mutation (simplified)
        private void PolynomialMutation(double[] x, double eta = 20.0)
        {
            for (int i = 0; i < x.Length; i++)
            {
                if (_rng.NextDouble() > MutationProbPerVar) continue;

                var v = _problem.Vars[i];
                double y = x[i];
                double yl = v.Min, yu = v.Max;

                if (yu - yl < 1e-12) continue;

                double delta1 = (y - yl) / (yu - yl);
                double delta2 = (yu - y) / (yu - yl);
                double rnd = _rng.NextDouble();
                double mutPow = 1.0 / (eta + 1.0);

                double deltaq;
                if (rnd <= 0.5)
                {
                    double xy = 1.0 - delta1;
                    double val = 2.0 * rnd + (1.0 - 2.0 * rnd) * Math.Pow(xy, eta + 1.0);
                    deltaq = Math.Pow(val, mutPow) - 1.0;
                }
                else
                {
                    double xy = 1.0 - delta2;
                    double val = 2.0 * (1.0 - rnd) + 2.0 * (rnd - 0.5) * Math.Pow(xy, eta + 1.0);
                    deltaq = 1.0 - Math.Pow(val, mutPow);
                }

                y = y + deltaq * (yu - yl);
                x[i] = v.Clamp(y);
            }
        }

        // ---------- Next population ----------
        private List<Individual> SelectNextPopulation(List<Individual> combined, int targetSize)
        {
            // group by rank
            var groups = combined.GroupBy(i => i.Rank).OrderBy(g => g.Key);

            var next = new List<Individual>(targetSize);
            foreach (var g in groups)
            {
                var front = g.ToList();
                if (next.Count + front.Count <= targetSize)
                {
                    next.AddRange(front);
                }
                else
                {
                    // fill remaining by crowding descending
                    front.Sort((a, b) => b.Crowding.CompareTo(a.Crowding));
                    int remaining = targetSize - next.Count;
                    next.AddRange(front.Take(remaining));
                    break;
                }
            }
            return next;
        }
    }

    // ============ Your car model (colleague fills this) ============
    public class CarModelProblem : IMultiObjectiveProblem
    {
        public IReadOnlyList<DesignVariable> Vars { get; } = new List<DesignVariable>
        {
            new DesignVariable("massKg", 900, 1800),
            new DesignVariable("Cd", 0.20, 0.40),
            new DesignVariable("areaM2", 1.8, 2.6),
            new DesignVariable("powerKW", 60, 250),
            new DesignVariable("gearRatio", 6, 14),
        };

        public (double f1, double f2) Evaluate(double[] x)
        {
            // TODO: implement realistic-ish physics or a simplified model.
            // Must return values to MINIMIZE:
            // f1 = -speed_kmh (because we want maximize speed)
            // f2 = energy_Wh_per_km or kWh/100km

            double speedKmh = ComputeTopSpeedKmh(x);
            double energyKwhPer100 = ComputeEnergyKwhPer100km(x);

            // Example constraint penalty (optional):
            // if speed < 120km/h add penalty to both
            if (speedKmh < 120)
            {
                double pen = (120 - speedKmh) * 10;
                return (-(speedKmh) + pen, energyKwhPer100 + pen);
            }

            return (-speedKmh, energyKwhPer100);
        }

        private double ComputeTopSpeedKmh(double[] x)
        {
            // Placeholder: replace with your formula
            // x: [mass, Cd, area, power, gear]
            double Cd = x[1], A = x[2], powerKW = x[3];

            // simplistic monotonic relationship:
            double speed = 50 + 1.6 * powerKW - 120 * Cd - 15 * (A - 2.2);
            return Math.Max(0, speed);
        }

        private double ComputeEnergyKwhPer100km(double[] x)
        {
            // Placeholder: replace with your formula
            double mass = x[0], Cd = x[1], A = x[2], gear = x[4];

            double baseCons = 12.0;
            double cons = baseCons
                          + 0.006 * (mass - 1200)
                          + 18.0 * (Cd - 0.28)
                          + 2.0 * (A - 2.2)
                          + 0.2 * (gear - 10);

            return Math.Max(1, cons);
        }
    }

    // ============ Entry point ============
    class Program
    {
        static void Main()
        {
            var problem = new CarModelProblem();
            var nsga2 = new Nsga2(problem, popSize: 150, generations: 200, mutationProbPerVar: 1.0 / problem.Vars.Count);

            var pareto = nsga2.Run();

            Console.WriteLine("\nFinal Pareto front (first 10):");
            foreach (var ind in pareto.Take(10))
            {
                double speed = -ind.F1;
                double energy = ind.F2;
                Console.WriteLine($"speed={speed:F1} km/h | energy={energy:F2} kWh/100km | x=[{string.Join(", ", ind.X.Select(v => v.ToString("F3")))}]");
            }
        }
    }
}
